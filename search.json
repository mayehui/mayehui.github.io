[{"title":"Hello World","url":"/2024/11/13/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start test actionCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"单例模式","url":"/2024/11/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"","categories":["面向对象设计","创建型"],"tags":["python","golang"]},{"title":"外观模式","url":"/2024/11/11/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","content":"","categories":["面向对象设计","结构型"],"tags":["python","golang"]},{"title":"工厂方法模式","url":"/2024/11/11/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","content":"","categories":["面向对象设计","创建型"],"tags":["python","golang"]},{"title":"抽象工厂模式","url":"/2024/11/11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","content":"","categories":["面向对象设计","创建型"],"tags":["python","golang"]},{"title":"简单工厂","url":"/2024/11/11/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/","content":"","categories":["面向对象设计","创建型"],"tags":["python","golang"]},{"title":"适配器模式","url":"/2024/11/11/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","content":"","categories":["面向对象设计","结构型"],"tags":["python","golang"]},{"title":"面向对象设计原则","url":"/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","content":"面向对象设计原则\n简介\nSOLID 原则是一个缩写，描述了表达软件开发原则的五项基本原则。 这些原则旨在提高软件的可维护性、灵活性、易维护性和可重用性。 SOLID 原则与软件架构和面向对象编程（OOP）的概念关系密切。 让我们通过 Flutter 逐一研究每条原则。\n\n\n1.单一功能原则(Single Responsibility Principle)\n每个类应只有一个引起其变化的原因，即每个类只负责一个功能或一个职责。这样可以减少类之间的耦合，使代码更加清晰。\n\n\n示例\n如果我们有一个名为User的类，它同时负责用户认证和用户信息管理，这就违反了单一职责原则。我们应该将其拆分为两个类：UserAuthentication和UserInfo。\n\n\n个人理解\n解耦和增强内聚性（高内聚，低耦合）\n\n\n2.开放-封闭原则(Open-Closed Principle)\n软件中的对象（类、模块、函数等）应该对扩展开放，对修改封闭。也就是说，当需要对功能进行扩展时，可以通过增加新代码而不是修改已有代码来实现。通常通过继承和接口实现该原则。\n\n\n示例\n如果我们需要在一个已经存在的类中增加新的功能，我们应该优先考虑通过继承或组合的方式实现，而不是直接修改这个类。\n\n\n个人理解\n对扩展开放，对修改关闭。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。\n根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。\n\n\n3. 里氏替换原则 (Liskov-Substitution Principle)\n子类对象必须能够替换父类对象，并且保证系统的行为不发生变化。即在使用父类的地方可以使用子类而不会出现问题。这可以确保继承关系的正确性，并避免出现违背继承关系的设计。\n\n\n示例如果我们有一个Animal类和一个Dog类（Dog是Animal的子类），那么我们应该确保Dog对象可以在任何需要Animal对象的地方使用，而不会出现错误。\n\n个人理解\n\n\n在任何父类出现的地方都可以用他的子类来替代（子类应当可以替换父类并出现在父类能够出现的任何地方）子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。\n子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性\n覆盖或实现父类的方法时输入参数可以被放大。即子类可以重载父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。\n覆盖或实现父类的方法时输出结果可以被缩小。\n\n4. 接口隔离原则 (Interface Segregation Principle)接口应该是细化和专门的，不要强迫实现类去实现不需要的接口方法。即多个小接口优于一个大接口，保持接口的单一职责。\n\n示例如果我们有一个包含许多方法的UserService接口，我们可以考虑将其拆分为几个更小的接口，如UserAuthenticationService、UserInfoService等。这样，客户端就可以只依赖于它们需要的接口，而不是被迫依赖于所有接口。\n\n个人理解\n不应该强迫客户程序依赖他们不需要使用的方法。\n一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口当中.\n\n\n5. 依赖倒置原则 (Dependency Inversion Principle)高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。通过依赖抽象而不是具体实现，可以使得高层模块和低层模块之间的耦合度降低，系统更易于维护和扩展。\n\n示例如果我们有一个UserController类和一个UserRepository类，UserController类不应该直接依赖于UserRepository类的具体实现，而应该依赖于一个抽象的UserRepositoryInterface接口。这样，我们就可以在不修改UserController类的情况下更换UserRepository的具体实现。\n\n个人理解\n要依赖于抽象，不要依赖于具体的实现\n\n\n高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）\n抽象不应该依赖细节（具体实现）\n细节（具体实现）应该依赖抽象。\n\n以上这些原则合起来可以简称为 SOLID 原则，它们是面向对象设计的核心思想。6.迪米特原则（拓展）\n\n\n\n示例如果我们有一个User类和一个Order类，User类不需要知道Order类的内部实现细节，只需要知道如何创建和获取订单即可。\n\n个人理解\n一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。（类间解耦，低耦合）意思就是降低各个对象之间的耦合，提高系统的可维护性；在模块之间只通过接口来通信，而不理会模块的内部工作原理，可以使各个模块的耦合成都降到最低，促进软件的复用\n\n\n7.组合&#x2F;聚合复用原则（拓展）\n\n示例如果我们有一个Shape类和一个Circle类（Circle是Shape的子类），我们应该考虑是否可以通过组合的方式实现，即Circle类中包含一个Shape对象，而不是直接继承自Shape类。\n\n个人理解\n尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。\n\n\n在复用时应优先考虑使用合成聚合而不是继承\n\n总结 我们对这七种设计原则有了一个基本的认知，接下来我们在根据功能特点提炼一下\n\n\n\n开闭原则：控制需求变动风险，缩小维护成本 \n这一条放在第一位来理解，它的含义是对扩展开放，对修改关闭。解释一下就是，我们写完的代码，不能因为需求变化就修改。我们可以通过新增代码的方式来解决变化的需求。\n当然，这是一种理想的状态，在现实中，我们要尽量的缩小这种修改。\n\n\n再解释一下这条原则的意义所在，我们采用逆向思维方式来想。如果每次需求变动都去修改原有的代码，那原有的代码就存在被修改错误的风险，当然这其中存在有意和无意的修改，都会导致原有正常运行的功能失效的风险，这样很有可能会展开可怕的蝴蝶效应，使维护工作剧增。说到底，开闭原则除了表面上的可扩展性强以外，在企业中更看重的是维护成本。\n\n所以，开闭原则是设计模式的第一大原则，以下几种原则，都是为此原则服务的。\n\n\n\n里氏替换原则：尽量使用精准的抽象类或接口\n\n此原则的含义是子类可以在任何地方替换它的父类。解释一下，这是多态的前提，我们后面很多所谓的灵活，都是不改变声明类型的情况下，改变实例化类来完成的需求变更。当然，继承的特性看似天然就满足这个条件。但这里更注重的是继承的应用问题，我们必须保证我们的子类和父类划分是精准的。\n\n\n单一职责原则：拆分到最小单位，解决复用和组合问题\n\n单一职责的含义是：类的职责单一，引起类变化的原因单一。解释一下，这也是灵活的前提，如果我们把类拆分成最小的职能单位，那组合与复用就简单的多了，如果一个类做的事情太多，在组合的时候，必然会产生不必要的方法出现，这实际上是一种污染。\n\n举个例子，我们在绘制图案的时候，用“点”组成图和用“直线”组成图，哪个更灵活呢？一定是“点”，它可以绘制任何图形，而直线只能绘制带有直线条的图案，它起码无法画圆。\n\n\n\n\n\n接口隔离原则：拆分，从接口开始\n接口隔离原则可以说是单一职责的必要手段，它的含义是尽量使用职能单一的接口，而不使用职能复杂、全面的接口。很好理解，接口是为了让子类实现的，如果子类想达到职能单一，那么接口也必须满足职能单一。\n\n\n相反，如果接口融合了多个不相关的方法，那它的子类就被迫要实现所有方法，尽管有些方法是根本用不到的。这就是接口污染。\n\n\n\n依赖倒置原则：面向抽象编程，解耦调用和被调用者。\n想要理解依赖倒置原则，必须先理解传统的解决方案。面相对象的初期的程序，被调用者依赖于调用者。也就是调用者决定被调用者有什么方法，有什么样的实现方式，这种结构在需求变更的时候，会付出很大的代价，甚至推翻重写。\n\n\n依赖倒置原则就是要求调用者和被调用者都依赖抽象，这样两者没有直接的关联和接触，在变动的时候，一方的变动不会影响另一方的变动。\n\n\n其实，依赖倒置和前面的原则是相辅相成的，都强调了抽象的重要性。\n\n\n\n迪米特原则：不和陌生人说话，又是找中介\n迪米特原则要求尽量的封装，尽量的独立，尽量的使用低级别的访问修饰符。这是封装特性的典型体现。\n\n\n一个类如果暴露太多私用的方法和字段，会让调用者很茫然。并且会给类造成不必要的判断代码。所以，我们使用尽量低的访问修饰符，让外界不知道我们的内部。这也是面向对象的基本思路。这是迪米特原则的一个特性，无法了解类更多的私有信息。\n\n\n另外，迪米特原则要求类之间的直接联系尽量的少，两个类的访问，通过第三个中介类来实现\n\n\n\n组合&#x2F;聚合原则：我只是用你的方法，我们不一定是同类\n此原则的含义是，如果只是达到代码复用的目的，尽量使用组合与聚合，而不是继承。这里需要解释一下，组合聚合只是引用其他的类的方法，而不会受引用的类的继承而改变血统。\n\n\n继承的耦合性更大，比如一个父类后来添加实现一个接口或者去掉一个接口，那子类可能会遭到毁灭性的编译错误，但如果只是组合聚合，只是引用类的方法，就不会有这种巨大的风险，同时也实现了复用。\n\n\n在结合实际场景使用时，应注意以下几点\n\n\na）高内聚、低耦合和单一职能的“冲突”\n\n实际上，这两者是一回事。内聚，要求一个类把所有相关的方法放在一起，初看是职能多，但有个“高”，就是要求把联系非常紧密的功能放在一起，也就是说，从整体看，是一个职能的才能放在一起，所以，两者是不同的表述而已。\n\n这里很多人理解成复合类，但复合类不是高内聚，而是杂乱的放在一起，是一种设计失误而已。\n\n\nb）多个单一职责接口的灵活性和声明类型问题\n\n如果一个类实现多个接口，那么这个类应该用哪个接口类型声明呢？应该是用一个抽象类来继承多个接口，而实现类来继承这个接口。声明的时候，类型是抽象类。\n\nc）最少知识原则和中介类泛滥两种极端情况这是另一种设计的失误。迪米特原则要求类之间要用中介来通讯，但类多了以后，会造成中介类泛滥的情况，这种情况，我们可以考虑中介模式，用一个总的中介类来实现。\n\n当然，设计模式都有自己的缺陷，迪米特原则也不是十全十美，交互类非常繁多的情况下，要适当的牺牲设计原则。\n\nd）继承和组合复用原则的 冲突\n\n继承也能实现复用，那这个原则是不是要抛弃继承了？不是的。\n\n继承更注重的是“血统”，也就是什么类型的。而组合聚合更注重的是借用“技能”。并且，组合聚合中，两个类是部分与整体的关系，组合聚合可以由多个类的技能组成。在C#和Java中只有单继承。\n\n\n这个原则不是告诉我们不用继承了，都用组合聚合，而是在“复用”这个点上，我们优先使用组合聚合。\n\n\n\nQ&amp;A\n1、这么多设计模式，都要学习和使用么？\n\n答：我们只是掌握总体的原则，然后学习常用的就行了。实际开发中也不是每种设计模式都会经常用到。因为归根结底，设计模式也好，架构也好，都是为需求服务的，没有需求业务模型，不能生搬硬套模式。我们在学习的时候，多学一些总是好的，但只是为了开阔自己的眼界。\n2、设计模式是规范么？是不是好的程序必须用设计模式？\n答：严格来说，好的程序遵循的是设计原则，而非设计模式。现在就出现很多新的演变出来的模式，这些都是因为出现了新业务的原因，设计模式不是规范，只是一种借鉴。\n3、使用设计模式会不会增加开发难度？\n答：开发阶段会的，而且会延长开发时间。但一个项目或产品从开始到结束，开发只是其中很小的一部分，考虑到维护和扩展成本，才会出现设计模式。从整体考虑，设计模式是减少了开发时间和成本的。\n\n\n参考《研磨设计模式》\n","categories":["面向对象设计"]}]